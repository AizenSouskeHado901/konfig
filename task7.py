def main(hex_str):
    # Преобразуем входную строку в целое число
    num = int(hex_str, 16)
    
    # Извлекаем битовые поля
    T1 = (num >> 0) & 0b111111     # Биты 0-5
    T2 = (num >> 6) & 0b11         # Биты 6-7
    T3 = (num >> 8) & 0b1111       # Биты 8-11
    
    # Поля T6, T5, T4 остаются на своих местах
    fixed_part = num & ~0b111111111111  # Обнуляем биты 0-11 (T3, T2, T1)
    
    # Переставляем поля T1, T2, T3 в новом порядке
    # T1 -> биты 4-9
    # T2 -> биты 10-11
    # T3 -> биты 0-3
    rearranged = (T1 << 4) | (T2 << 10) | (T3 << 0)
    
    # Объединяем неизменную часть и переставленные биты
    result = fixed_part | rearranged
    
    # Возвращаем результат в виде шестнадцатеричной строки
    return hex(result)

# Тесты
print(main('0x12638d7a'))  # Ожидается: '0x126387ad'
print(main('0x3283a88c'))  # Ожидается: '0x3283a8c8'
print(main('0x2d5c9082'))  # Ожидается: '0x2d5c9820'
print(main('0xd43298d'))   # Ожидается: '0xd4328d9'

def main(decimal_str):
    value = int(decimal_str)  # преобразуем строку в целое число

    # Маски и сдвиги:
    T1 = value & 0xFF             # 0-7 биты
    T2 = (value >> 8) & 0xFF      # 8-15 биты
    T3 = (value >> 16) & 0x3F     # 16-21 биты (6 бит)

    return {
        'T1': str(T1),
        'T2': str(T2),
        'T3': str(T3),
    }


def main(value):
    L1 = value & 0b111111            # 6 бит: 0–5
    L2 = (value >> 6) & 0b1111111111 # 10 бит: 6–15
    L3 = (value >> 16) & 0b1         # 1 бит: 16
    L4 = (value >> 17) & 0b111111111 # 9 бит: 17–25
    L5 = (value >> 26) & 0b1         # 1 бит: 26

    return [
        ('L1', L1),
        ('L2', L2),
        ('L3', L3),
        ('L4', L4),
        ('L5', L5),
    ]
